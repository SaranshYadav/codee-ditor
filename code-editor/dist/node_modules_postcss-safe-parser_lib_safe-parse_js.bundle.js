(self["webpackChunkmyModule"] = self["webpackChunkmyModule"] || []).push([["node_modules_postcss-safe-parser_lib_safe-parse_js"],{

/***/ "./node_modules/postcss-safe-parser/lib/safe-parse.js":
/*!************************************************************!*\
  !*** ./node_modules/postcss-safe-parser/lib/safe-parse.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

let { Input } = __webpack_require__(/*! postcss */ "./node_modules/postcss/lib/postcss.js")

let SafeParser = __webpack_require__(/*! ./safe-parser */ "./node_modules/postcss-safe-parser/lib/safe-parser.js")

module.exports = function safeParse(css, opts) {
  let input = new Input(css, opts)

  let parser = new SafeParser(input)
  parser.parse()

  return parser.root
}


/***/ }),

/***/ "./node_modules/postcss-safe-parser/lib/safe-parser.js":
/*!*************************************************************!*\
  !*** ./node_modules/postcss-safe-parser/lib/safe-parser.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

let tokenizer = __webpack_require__(/*! postcss/lib/tokenize */ "./node_modules/postcss/lib/tokenize.js")
let Comment = __webpack_require__(/*! postcss/lib/comment */ "./node_modules/postcss/lib/comment.js")
let Parser = __webpack_require__(/*! postcss/lib/parser */ "./node_modules/postcss/lib/parser.js")

class SafeParser extends Parser {
  checkMissedSemicolon() {}

  comment(token) {
    let node = new Comment()
    this.init(node, token[2])
    let pos =
      this.input.fromOffset(token[3]) ||
      this.input.fromOffset(this.input.css.length - 1)
    node.source.end = {
      column: pos.col,
      line: pos.line,
      offset: token[3] + 1
    }

    let text = token[1].slice(2)
    if (text.slice(-2) === '*/') text = text.slice(0, -2)

    if (/^\s*$/.test(text)) {
      node.text = ''
      node.raws.left = text
      node.raws.right = ''
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/)
      node.text = match[2]
      node.raws.left = match[1]
      node.raws.right = match[3]
    }
  }

  createTokenizer() {
    this.tokenizer = tokenizer(this.input, { ignoreErrors: true })
  }

  decl(tokens) {
    if (tokens.length > 1 && tokens.some(i => i[0] === 'word')) {
      super.decl(tokens)
    }
  }

  doubleColon() {}

  endFile() {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon
    }
    this.current.raws.after = (this.current.raws.after || '') + this.spaces

    while (this.current.parent) {
      this.current = this.current.parent
      this.current.raws.after = ''
    }
    this.root.source.end = this.getPosition(this.tokenizer.position())
  }

  precheckMissedSemicolon(tokens) {
    let colon = this.colon(tokens)
    if (colon === false) return

    let nextStart, prevEnd
    for (nextStart = colon - 1; nextStart >= 0; nextStart--) {
      if (tokens[nextStart][0] === 'word') break
    }
    if (nextStart === 0) return

    for (prevEnd = nextStart - 1; prevEnd >= 0; prevEnd--) {
      if (tokens[prevEnd][0] !== 'space') {
        prevEnd += 1
        break
      }
    }

    let other = tokens.slice(nextStart)
    let spaces = tokens.slice(prevEnd, nextStart)
    tokens.splice(prevEnd, tokens.length - prevEnd)
    this.spaces = spaces.map(i => i[1]).join('')

    this.decl(other)
  }

  unclosedBracket() {}

  unexpectedClose() {
    this.current.raws.after += '}'
  }

  unknownWord(tokens) {
    this.spaces += tokens.map(i => i[1]).join('')
  }

  unnamedAtrule(node) {
    node.name = ''
  }
}

module.exports = SafeParser


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX3Bvc3Rjc3Mtc2FmZS1wYXJzZXJfbGliX3NhZmUtcGFyc2VfanMuYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsTUFBTSxRQUFRLEVBQUUsbUJBQU8sQ0FBQyxzREFBUzs7QUFFakMsaUJBQWlCLG1CQUFPLENBQUMsNEVBQWU7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7OztBQ1hBLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFzQjtBQUM5QyxjQUFjLG1CQUFPLENBQUMsa0VBQXFCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyxnRUFBb0I7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxvQkFBb0I7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlNb2R1bGUvLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1zYWZlLXBhcnNlci9saWIvc2FmZS1wYXJzZS5qcyIsIndlYnBhY2s6Ly9teU1vZHVsZS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLXNhZmUtcGFyc2VyL2xpYi9zYWZlLXBhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgeyBJbnB1dCB9ID0gcmVxdWlyZSgncG9zdGNzcycpXG5cbmxldCBTYWZlUGFyc2VyID0gcmVxdWlyZSgnLi9zYWZlLXBhcnNlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2FmZVBhcnNlKGNzcywgb3B0cykge1xuICBsZXQgaW5wdXQgPSBuZXcgSW5wdXQoY3NzLCBvcHRzKVxuXG4gIGxldCBwYXJzZXIgPSBuZXcgU2FmZVBhcnNlcihpbnB1dClcbiAgcGFyc2VyLnBhcnNlKClcblxuICByZXR1cm4gcGFyc2VyLnJvb3Rcbn1cbiIsImxldCB0b2tlbml6ZXIgPSByZXF1aXJlKCdwb3N0Y3NzL2xpYi90b2tlbml6ZScpXG5sZXQgQ29tbWVudCA9IHJlcXVpcmUoJ3Bvc3Rjc3MvbGliL2NvbW1lbnQnKVxubGV0IFBhcnNlciA9IHJlcXVpcmUoJ3Bvc3Rjc3MvbGliL3BhcnNlcicpXG5cbmNsYXNzIFNhZmVQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICBjaGVja01pc3NlZFNlbWljb2xvbigpIHt9XG5cbiAgY29tbWVudCh0b2tlbikge1xuICAgIGxldCBub2RlID0gbmV3IENvbW1lbnQoKVxuICAgIHRoaXMuaW5pdChub2RlLCB0b2tlblsyXSlcbiAgICBsZXQgcG9zID1cbiAgICAgIHRoaXMuaW5wdXQuZnJvbU9mZnNldCh0b2tlblszXSkgfHxcbiAgICAgIHRoaXMuaW5wdXQuZnJvbU9mZnNldCh0aGlzLmlucHV0LmNzcy5sZW5ndGggLSAxKVxuICAgIG5vZGUuc291cmNlLmVuZCA9IHtcbiAgICAgIGNvbHVtbjogcG9zLmNvbCxcbiAgICAgIGxpbmU6IHBvcy5saW5lLFxuICAgICAgb2Zmc2V0OiB0b2tlblszXSArIDFcbiAgICB9XG5cbiAgICBsZXQgdGV4dCA9IHRva2VuWzFdLnNsaWNlKDIpXG4gICAgaWYgKHRleHQuc2xpY2UoLTIpID09PSAnKi8nKSB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMilcblxuICAgIGlmICgvXlxccyokLy50ZXN0KHRleHQpKSB7XG4gICAgICBub2RlLnRleHQgPSAnJ1xuICAgICAgbm9kZS5yYXdzLmxlZnQgPSB0ZXh0XG4gICAgICBub2RlLnJhd3MucmlnaHQgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWF0Y2ggPSB0ZXh0Lm1hdGNoKC9eKFxccyopKFteXSpcXFMpKFxccyopJC8pXG4gICAgICBub2RlLnRleHQgPSBtYXRjaFsyXVxuICAgICAgbm9kZS5yYXdzLmxlZnQgPSBtYXRjaFsxXVxuICAgICAgbm9kZS5yYXdzLnJpZ2h0ID0gbWF0Y2hbM11cbiAgICB9XG4gIH1cblxuICBjcmVhdGVUb2tlbml6ZXIoKSB7XG4gICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXIodGhpcy5pbnB1dCwgeyBpZ25vcmVFcnJvcnM6IHRydWUgfSlcbiAgfVxuXG4gIGRlY2wodG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggPiAxICYmIHRva2Vucy5zb21lKGkgPT4gaVswXSA9PT0gJ3dvcmQnKSkge1xuICAgICAgc3VwZXIuZGVjbCh0b2tlbnMpXG4gICAgfVxuICB9XG5cbiAgZG91YmxlQ29sb24oKSB7fVxuXG4gIGVuZEZpbGUoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC5ub2RlcyAmJiB0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmN1cnJlbnQucmF3cy5zZW1pY29sb24gPSB0aGlzLnNlbWljb2xvblxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCAnJykgKyB0aGlzLnNwYWNlc1xuXG4gICAgd2hpbGUgKHRoaXMuY3VycmVudC5wYXJlbnQpIHtcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuY3VycmVudC5wYXJlbnRcbiAgICAgIHRoaXMuY3VycmVudC5yYXdzLmFmdGVyID0gJydcbiAgICB9XG4gICAgdGhpcy5yb290LnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRoaXMudG9rZW5pemVyLnBvc2l0aW9uKCkpXG4gIH1cblxuICBwcmVjaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpIHtcbiAgICBsZXQgY29sb24gPSB0aGlzLmNvbG9uKHRva2VucylcbiAgICBpZiAoY29sb24gPT09IGZhbHNlKSByZXR1cm5cblxuICAgIGxldCBuZXh0U3RhcnQsIHByZXZFbmRcbiAgICBmb3IgKG5leHRTdGFydCA9IGNvbG9uIC0gMTsgbmV4dFN0YXJ0ID49IDA7IG5leHRTdGFydC0tKSB7XG4gICAgICBpZiAodG9rZW5zW25leHRTdGFydF1bMF0gPT09ICd3b3JkJykgYnJlYWtcbiAgICB9XG4gICAgaWYgKG5leHRTdGFydCA9PT0gMCkgcmV0dXJuXG5cbiAgICBmb3IgKHByZXZFbmQgPSBuZXh0U3RhcnQgLSAxOyBwcmV2RW5kID49IDA7IHByZXZFbmQtLSkge1xuICAgICAgaWYgKHRva2Vuc1twcmV2RW5kXVswXSAhPT0gJ3NwYWNlJykge1xuICAgICAgICBwcmV2RW5kICs9IDFcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgb3RoZXIgPSB0b2tlbnMuc2xpY2UobmV4dFN0YXJ0KVxuICAgIGxldCBzcGFjZXMgPSB0b2tlbnMuc2xpY2UocHJldkVuZCwgbmV4dFN0YXJ0KVxuICAgIHRva2Vucy5zcGxpY2UocHJldkVuZCwgdG9rZW5zLmxlbmd0aCAtIHByZXZFbmQpXG4gICAgdGhpcy5zcGFjZXMgPSBzcGFjZXMubWFwKGkgPT4gaVsxXSkuam9pbignJylcblxuICAgIHRoaXMuZGVjbChvdGhlcilcbiAgfVxuXG4gIHVuY2xvc2VkQnJhY2tldCgpIHt9XG5cbiAgdW5leHBlY3RlZENsb3NlKCkge1xuICAgIHRoaXMuY3VycmVudC5yYXdzLmFmdGVyICs9ICd9J1xuICB9XG5cbiAgdW5rbm93bldvcmQodG9rZW5zKSB7XG4gICAgdGhpcy5zcGFjZXMgKz0gdG9rZW5zLm1hcChpID0+IGlbMV0pLmpvaW4oJycpXG4gIH1cblxuICB1bm5hbWVkQXRydWxlKG5vZGUpIHtcbiAgICBub2RlLm5hbWUgPSAnJ1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2FmZVBhcnNlclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9